#define _WIN32_DCOM

#include <Windows.h>
#include <comdef.h>
#include <taskschd.h>
#include <tlhelp32.h>
#include <lm.h>
#include <sddl.h>

#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "taskschd.lib")
#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "Kernel32.lib")

#include <iostream>

#define LSA_WIN_STANDARD_BUFFER_SIZE           0x000000200L

namespace Utils {

	void WaitFor()
	{
		std::wcout << L"Press a key ...\n";
		std::wstring tmp;
		std::wcin >> tmp;
	}

	PVOID AllocateMemory(DWORD dwSize)
	{
		return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
	}

	BOOL FreeMemory(LPVOID memory)
	{
		return HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, memory);
	}


}


namespace AVADDON {

	struct Result {
		BOOL bresult;
		std::wstring wsValue;
	};

	wchar_t* ToWideString(PCHAR _str)
	{
		int n = MultiByteToWideChar(CP_UTF8, 0, _str, -1, NULL, 0);
		wchar_t* wstr = new wchar_t[n];
		MultiByteToWideChar(CP_UTF8, 0, _str, -1, wstr, n);
		return wstr;
	}

	BOOL TerminateProcess(DWORD dwProcessId, UINT uExitCode)
	{
		DWORD dwDesiredAccess = PROCESS_TERMINATE;
		BOOL  bInheritHandle = FALSE;
		HANDLE hProcess = OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
		if (hProcess == NULL)
			return FALSE;

		BOOL result = ::TerminateProcess(hProcess, uExitCode);
		CloseHandle(hProcess);
		return result;
	}

	BOOL KillProcess(std::wstring path_name)
	{

		HANDLE hProcessSnap;
		HANDLE hProcess;
		PROCESSENTRY32 pe32;
		DWORD dwPriorityClass;

		hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (hProcessSnap == INVALID_HANDLE_VALUE)
		{
			return(FALSE);
		}

		pe32.dwSize = sizeof(PROCESSENTRY32);

		if (!Process32First(hProcessSnap, &pe32))
		{
			CloseHandle(hProcessSnap);
			return(FALSE);
		}


		do
		{
			std::wstring wszExeFile(AVADDON::ToWideString(pe32.szExeFile));
			if (wszExeFile == path_name)
			{
				AVADDON::TerminateProcess(pe32.th32ProcessID, 1);
			}
		} while (Process32Next(hProcessSnap, &pe32));

		CloseHandle(hProcessSnap);
		return(TRUE);
	}


	Result GetTaskPath()
	{

		Result ret;
		ret.bresult = FALSE;

		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
		{
			std::wcerr << L"CoInitializeEx failed" << std::endl;

			return ret;
		}

		hr = CoInitializeSecurity(
			NULL,
			-1,
			NULL,
			NULL,
			RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
			RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL,
			0,
			NULL);

		if (FAILED(hr))
		{
			std::wcerr << L"CoInitializeSecurity failed" << std::endl;
			CoUninitialize();

			return ret;
		}

		ITaskService* pService = NULL;
		hr = CoCreateInstance(CLSID_TaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskService,
			(void**)&pService);

		if (FAILED(hr))
		{
			std::wcerr << L"Failed to CoCreate an instance of the TaskService class" << std::endl;
			CoUninitialize();

			return ret;
		}

		hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

		if (FAILED(hr))
		{
			std::wcerr << L"ITaskService::Connect failed" << std::endl;
			pService->Release();
			CoUninitialize();

			return ret;
		}

		ITaskFolder* pRootFolder = NULL;
		hr = pService->GetFolder(_bstr_t(L"\\"), &pRootFolder);
		pService->Release();

		if (FAILED(hr))
		{
			std::wcerr << L"Cannot get Root Folder pointer" << std::endl;
			CoUninitialize();

			return ret;
		}

		IRegisteredTaskCollection* pTaskCollection = NULL;
		hr = pRootFolder->GetTasks(TASK_ENUM_HIDDEN, &pTaskCollection);

		pRootFolder->Release();

		if (FAILED(hr))
		{
			std::wcerr << L"Cannot get the registered tasks" << std::endl;
			CoUninitialize();

			return ret;
		}

		LONG numTasks = 0;
		hr = pTaskCollection->get_Count(&numTasks);

		if (numTasks == 0)
		{
			std::wcerr << L"No Tasks are currently running" << std::endl;
			pTaskCollection->Release();
			CoUninitialize();

			return ret;
		}

		TASK_STATE taskState;

		for (LONG i = 0; i < numTasks; i++)
		{
			IRegisteredTask* pRegisteredTask = NULL;
			hr = pTaskCollection->get_Item(_variant_t(i + 1), &pRegisteredTask);

			if (SUCCEEDED(hr))
			{
				BSTR taskName = NULL;
				ITaskDefinition* pTaskDefinition;
				IActionCollection* pActions;
				IAction* pAction;
				IExecAction* pExecAction;
				BSTR path_name = NULL;

				hr = pRegisteredTask->get_Name(&taskName);
				if (std::wstring(taskName) == L"update")
				{
					hr = pRegisteredTask->get_Definition(&pTaskDefinition);
					hr = pTaskDefinition->get_Actions(&pActions);
					hr = pActions->get_Item(1, &pAction);


					if (SUCCEEDED(hr = pAction->QueryInterface(IID_PPV_ARGS(&pExecAction))))
					{
						pExecAction->get_Path(&path_name);
						pExecAction->Release();
					}


					if (SUCCEEDED(hr))
					{
						std::wcout << L"[*] Avaddon task name :: " << taskName << std::endl;
						std::wcout << L"[*] Avaddon path name :: " << path_name << std::endl;
						ret.bresult = TRUE;
						ret.wsValue = std::wstring(path_name);
						return ret;
					}
				}
			}

			pRegisteredTask->Release();
		}

		pTaskCollection->Release();
		CoUninitialize();

		return ret;
	}

	BOOL DeleteTask()
	{
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
		{
			std::wcerr << L"CoInitializeEx failed" << std::endl;

			return FALSE;
		}

		ITaskService* pITS;

		if (FAILED(CoCreateInstance(CLSID_TaskScheduler, nullptr, CLSCTX_INPROC_SERVER, IID_ITaskService, (void**)&pITS))) {
			CoUninitialize();
			return FALSE;
		}
		if (FAILED(pITS->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t()))) {

			pITS->Release();
			CoUninitialize();
			return FALSE;
		}
		ITaskFolder* pITF;
		if (FAILED(pITS->GetFolder(_bstr_t(L"\\"), &pITF))) {
			pITS->Release();
			CoUninitialize();
			return FALSE;
		}
		pITS->Release();

		if (FAILED(pITF->DeleteTask(_bstr_t(L"update"), 0))) {
			pITF->Release();
			CoUninitialize();
			return FALSE;
		}
		pITF->Release();

		CoUninitialize();


		return TRUE;
	}

	BOOL DeleteRegistry()
	{
		HKEY hKey = NULL;
		std::wcout << L"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run" << std::endl;
		long lReturn = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
			L"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run",
			0L,
			KEY_SET_VALUE,
			&hKey);
		if (lReturn == ERROR_SUCCESS)
		{
			lReturn = RegDeleteValueW(hKey, L"update");
			lReturn = RegCloseKey(hKey);
		}
		else
			RegCloseKey(hKey);


		return TRUE;


	}

	std::wstring ResolveSID(LPWSTR lpszUsername)
	{

		wchar_t			SidFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE];
		wchar_t			RefDFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE];
		DWORD			cbSidFromLookupName, cchRefDFromLookupName;
		SID_NAME_USE	UseFromLookupName;

		BOOL BoolStatus = TRUE;
		LPWSTR pszSid = NULL;

		BoolStatus = LookupAccountNameW(NULL,
			lpszUsername,
			(PSID)SidFromLookupName,
			&cbSidFromLookupName,
			RefDFromLookupName,
			&cchRefDFromLookupName,
			&UseFromLookupName
			);

		BoolStatus = LookupAccountNameW(NULL,
			lpszUsername,
			(PSID)SidFromLookupName,
			&cbSidFromLookupName,
			RefDFromLookupName,
			&cchRefDFromLookupName,
			&UseFromLookupName
			);

		ConvertSidToStringSidW((PSID)SidFromLookupName, &pszSid);

		std::wstring str_sid(pszSid);
		LocalFree(pszSid);

		return str_sid;
	}


	VOID DeleteUsersRegistry()
	{
		NET_API_STATUS nStatus;
		LPUSER_INFO_0 pBuf = NULL;
		LPUSER_INFO_0 pTmpBuf = NULL;
		DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
		DWORD dwEntriesRead = 0;
		DWORD dwTotalEntries = 0;
		DWORD dwResumeHandle = 0;
		DWORD i;
		DWORD dwTotalCount = 0;

		do {

			nStatus = NetUserEnum(NULL,
				0,
				FILTER_NORMAL_ACCOUNT,
				(LPBYTE*)&pBuf,
				dwPrefMaxLen,
				&dwEntriesRead,
				&dwTotalEntries,
				&dwResumeHandle);


			if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
			{
				if ((pTmpBuf = pBuf) != NULL)
				{
					for (i = 0; (i < dwEntriesRead); i++)
					{
						if (pTmpBuf == NULL)
						{
							//
							break;
						}

						PSID pSid = NULL;
						DWORD dwSizeSid = 0;
						SID_NAME_USE sidName;
						LPWSTR lpRDN = NULL;
						DWORD cch = 0;


						std::wstring reg_key = AVADDON::ResolveSID(pTmpBuf->usri0_name) + L"\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
						std::wcout << reg_key << std::endl;

						HKEY hKey = NULL;
						long lReturn = RegOpenKeyExW(HKEY_USERS,
							reg_key.c_str(),
							0L,
							KEY_SET_VALUE,
							&hKey);

						if (lReturn == ERROR_SUCCESS)
						{
							lReturn = RegDeleteValueW(hKey, L"update");
							lReturn = RegCloseKey(hKey);
						}
						else
							RegCloseKey(hKey);

						pTmpBuf++;
						dwTotalCount++;
					}
				}

			}

			if (pBuf != NULL) {
				NetApiBufferFree(pBuf);
				pBuf = NULL;
			}
		} while (nStatus == ERROR_MORE_DATA);

		if (pBuf != NULL)
			NetApiBufferFree(pBuf);
	}

	VOID RestoreBackUP()
	{
		system("bcdedit.exe /set {default} recoveryenabled Yes");
		return;
	}

	BOOL RestoreULA()
	{
		HKEY hKey = NULL;

		DWORD EnableLUA = 1;
		DWORD ConsentPromptBehaviorAdmin = 5;
		DWORD ConsentPromptBehaviorUser = 3;
		DWORD PromptOnSecureDesktop = 1;

		long lReturn = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
			L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
			0L,
			KEY_SET_VALUE,
			&hKey);
		if (lReturn == ERROR_SUCCESS)
		{
			RegSetValueExW(hKey, L"EnableLUA", 0, REG_DWORD, (const BYTE*)&EnableLUA, sizeof(EnableLUA));
			RegSetValueExW(hKey, L"ConsentPromptBehaviorAdmin", 0, REG_DWORD, (const BYTE*)&ConsentPromptBehaviorAdmin, sizeof(ConsentPromptBehaviorAdmin));
			RegSetValueExW(hKey, L"ConsentPromptBehaviorUser", 0, REG_DWORD, (const BYTE*)&ConsentPromptBehaviorUser, sizeof(ConsentPromptBehaviorUser));
			RegSetValueExW(hKey, L"PromptOnSecureDesktop", 0, REG_DWORD, (const BYTE*)&PromptOnSecureDesktop, sizeof(PromptOnSecureDesktop));

			RegCloseKey(hKey);
		}
		else {
			RegCloseKey(hKey);
			return FALSE;
		}


		return TRUE;
	}
}


int wmain(int argc, wchar_t* argv[])
{
	std::wcout << L" --- AVADDON REMOVAL SOFTWARE --- " << std::endl;

	AVADDON::Result ret = AVADDON::GetTaskPath();

	if (ret.bresult == TRUE) {


		std::wstring exe_name = ret.wsValue.substr(ret.wsValue.find_last_of(L"\\") + 1);

		std::wcout << L"[+] Killing AVADDON process ... " << exe_name << std::endl;

		AVADDON::KillProcess(exe_name);

		std::wcout << L"[+] Removing malware file " << ret.wsValue << std::endl;
		DeleteFileW(ret.wsValue.c_str());

		std::wcout << L"[+] Removing tasks ..." << std::endl;
		AVADDON::DeleteTask();

	}
	else
		std::wcout << L"[-] AVADDON not found" << std::endl;

	std::wcout << L"[+] Cleaning registries ..." << std::endl;

	AVADDON::DeleteRegistry();
	AVADDON::DeleteUsersRegistry();

	std::wcout << L"[+] Restoring backup settings ..." << std::endl;
	AVADDON::RestoreBackUP();

	std::wcout << L"[+] Restoring UAC settings ..." << std::endl;
	AVADDON::RestoreULA();

	std::wcout << L"[+] Please reboot your computer ..." << std::endl;

	Utils::WaitFor();

	

	return 0;
}

